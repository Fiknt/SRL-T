{$DEFINE SRL_TPOINTARRAY_INCLUDED}
{$IFNDEF SRL_UTILS}
  {$I SRL/utils.simba}
{$ENDIF}

(*
TPointArray
=============
TPointArray related methods
*)

{
function TPointArray.Combine(Other: TPointArray): TPointArray; 
begin
  Result.SetLength(Self.Length() + Other.Length());
  if self.Length() > 0 then
    MemMove(self[0], result[0], self.Length()*SizeOf(self[0]));
  if Other.Length() > 0 then
    MemMove(Other[0], result[Self.Length()], Other.Length()*SizeOf(Other[0]));
end;


function TPointArray.Equals(Other:TPointArray): Boolean; 
begin
  if (Self.Length() <> Other.Length()) then Exit(False);
  if (Self.Length() = 0) then Exit(True);
  Result := CompareMem(Self[0], Other[0], self.Length()*SizeOf(self[0]));
end;
}

//--| Type helpers (extended) |------------------------------------------------>
//----------------------------------------------------------------------------->
(*
TPointArray.Mean
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Mean(): TPoint; 

Wraps Simba's TPAMiddle
*)
function TPointArray.Mean: TPoint; overload;
begin
  Result := MiddleTPA(self);
end;


(*
TPointArray.MeanEx
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.MeanEx(): Vector2; 

Middle as a Vector.
*)
function TPointArray.MeanEx(): Vector2; 
var
  i,x,y: Int64;
begin
  for i:=0 to Self.High() do
  begin
    Inc(x, Self[i].x);
    Inc(y, Self[i].y);
  end;
  Result.x := x / Self.Length();
  Result.y := y / Self.Length();
end;

function TPointArray.Median: TPoint; overload;
begin
  Result := MedianTPA(Self);
end;

(*
TPointArray.Sort
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    procedure TPointArray.Sort(From:TPoint=[0,0]);

Wraps Simba's `SortTPAFrom`
*)
procedure TPointArray.Sort(From:TPoint=[0,0]); overload;
begin
  SortTPAFrom(self, From);
end;

(*
TPointArray.Sorted
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Sorted(From:TPoint=[0,0]): TPointArray;

Wraps Simba's `SortTPAFrom`, produces a sorted copy.
*)
function TPointArray.Sorted(From:TPoint=[0,0]): TPointArray; overload;
begin
  Result := Self.Copy();
  SortTPAFrom(Result, From);
end;

(*
TPointArray.SortByX
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    procedure TPointArray.SortByX(LowToHi:Boolean=True);

Wraps Simba's `SortTPAByX`
*)
procedure TPointArray.SortByX(LowToHi:Boolean=True);
begin
  SortTPAByX(self, LowToHi);
end;

(*
TPointArray.SortByY
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    procedure TPointArray.SortByY(LowToHi:Boolean=True);

Wraps Simba's `SortTPAByY`
*)
procedure TPointArray.SortByY(LowToHi:Boolean=True);
begin
  SortTPAByY(self, LowToHi);
end;


(*
TPointArray.SortByRow
~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    procedure TPointArray.SortByRow(reverse:Boolean=False);

Sorts a given TPointArray TPA row-by-row, starting from the smallest Y coordinate to the largest Y coordinate, and for every row from the smallest X coordinate to the largest X coordinate.
*)
procedure TPointArray.SortByRow(reverse:Boolean=False);
var
  i,hi,w: Int32;
  Weights: TIntegerArray;
  area : TBox;
begin
  Hi := self.High();
  if Hi <= 1 then Exit;
  area := GetTPABounds(self);
  w := Area.X2 - Area.X1 + 1;
  Weights.SetLength(hi+1);
  for i:=0 to Hi do
    Weights[i] := self[i].y * W + self[i].x;
  Self.Sort(Weights, not reverse);
end;


(*
TPointArray.SortByColumn
~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    procedure TPointArray.SortByColumn(reverse:Boolean=False);

much like SortByRow, but the order of the column comes first
*)
procedure TPointArray.SortByColumn(reverse:Boolean=False);
var
  i,Hi,H: Int32;
  Weights: TIntegerArray;
  area: TBox;
begin
  Hi := self.High();
  if Hi <= 1 then Exit;
  Area := GetTPABounds(self);
  H := Area.Y2 - Area.Y1 + 1;
  Weights.SetLength(Hi+1);
  for i := 0 to Hi do
    Weights[i] := self[i].x * H + self[i].y;
  Self.Sort(Weights, not reverse);
end;

(*
TPointArray.SortFromLine
~~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    procedure TPointArray.SortFromLine(p,q:TPoint; reverse:Boolean=False);

The name tells the story
*)
procedure TPointArray.SortFromLine(p,q:TPoint; reverse:Boolean=False);
var
  i,hi: Int32;
  Weights: TIntegerArray;
begin
  Hi := self.High();
  if Hi <= 1 then Exit;
  Weights.SetLength(hi+1);
  for i:=0 to Hi do
    Weights[i] := Ceil(srl.DistToLine(self[i],p,q));
  Self.Sort(Weights, not reverse);
end;

(*
TPointArray.Bounds
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Bounds(): TBox; 

Wraps Simba's GetTPABounds
*)
function TPointArray.Bounds(): TBox; 
begin
  if Self.Length() = 1 then
    Exit(TBox([Self[0].x, Self[0].y, Self[0].x, Self[0].y]));

  Result := GetTPABounds(Self);
end;

(*
TPointArray.Edges
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Edges(): TPointArray; 

Filters all points out of the given TPointArray which aren't edge-points. 
Edge-points are points that are on the edge of the TPA, not completely surrounded by other points. 
Same as Simba's `FindTPAEdges`
*)
function TPointArray.Edges(): TPointArray; 
begin
  Result := FindTPAEdges(Self);
end;

(*
TPointArray.Cluster
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Cluster(dist:Int32): T2DPointArray; 
    function TPointArray.Cluster(distX,distY:Int32): T2DPointArray;  overload;

Smart wrapper of Simba's `ClusterTPA` and `ClusterTPAEx` (fall backs to `SplitTPA` when it's better suited)
*)
function TPointArray.Cluster(dist: Int32): T2DPointArray; 
begin
  if (Self.Length() < 700) then
    Result := SplitTPA(Self, dist)
  else
    Result := ClusterTPA(Self, dist);
end;

function TPointArray.Cluster(distX,distY: Int32): T2DPointArray;  overload;
begin
  if (Self.Length() < 1200) then
    Result := SplitTPAEx(Self, distX, distY)
  else 
    Result := ClusterTPAEx(Self, distX, distY);
end;

(*
TPointArray.Split
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Split(dist:Int32): T2DPointArray; 
    function TPointArray.Split(distX,distY:Int32): T2DPointArray;  overload;

Wraps Simba's `SplitTPA` and `SplitTPAEx`
*)
function TPointArray.Split(dist: Int32): T2DPointArray; 
begin
  Result := SplitTPA(Self, dist);
end; 

function TPointArray.Split(distX,distY: Int32): T2DPointArray;  overload;
begin
  Result := SplitTPAEx(Self, distX, distY);
end;


(*
TPointArray.ToATPA
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.ToATPA(WH:Int32): T2DPointArray; 
    function TPointArray.ToATPA(W,H:Int32): T2DPointArray;  overload;

Wraps Simba's `TPAToATPA` and `TPAToATPAEx`
*)
function TPointArray.ToATPA(WH:Int32): T2DPointArray; 
begin
  Result := TPAToATPA(Self, WH);
end; 

function TPointArray.ToATPA(W,H:Int32): T2DPointArray;  overload;
begin
  Result := TPAToATPAEx(Self, W,H);
end; 

(*
TPointArray.Offset
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Offset(off: TPoint): TPointArray;

Wraps Simba's `OffsetTPA`
*)
function TPointArray.Offset(X, Y: Int32): TPointArray;  overload;
begin
  Result := Self.Copy();

  OffsetTPA(Result, [X, Y]);
end;

function TPointArray.Offset(off: TPoint): TPointArray;  overload;
begin
  Result := Self.Offset(Off.X, Off.Y);
end;

(*
TPointArray.Invert
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Invert(Area:TBox=[0,0,-1,-1]): TPointArray; 

Inverts the shape based on the area covered, alternatively the given area.
Same as `ReturnPointsNotInTPA` in Simba.
*)
function TPointArray.Invert(Area:TBox=[0,0,-1,-1]): TPointArray; 
begin
  if Area = Box(0,0,-1,-1) then
    Area := Self.Bounds();
  Result := ReturnPointsNotInTPA(Self, Area);
end;

(*
TPointArray.FilterBox
~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.FilterBox(Box: TBox): TPointArray; 

Returns a filtered version of the TPA.
Same as Simba's `FilterPointsBox`
*)
function TPointArray.FilterBox(Box: TBox): TPointArray; 
begin
  Result := Self.Copy();
  FilterPointsBox(Result, Box.X1, Box.Y1, Box.X2, Box.Y2);
end;

(*
TPointArray.FilterBox
~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.FilterDist(MinDist,MaxDist: Double; Mx,My: Int32): TPointArray; 

Returns a filtered version of the TPA.
Same as Simba's `FilterPointsDist`
*)
function TPointArray.FilterDist(MinDist,MaxDist: Double; Mx,My: Int32): TPointArray; 
begin
  Result := Self.Copy();
  FilterPointsDist(Result, MinDist, MaxDist, Mx,My);
end;


(*
TPointArray.FilterDuplicates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.FilterDuplicates(): TPointArray;

Returns a copy where all duplicate points are removed.
*)
function TPointArray.FilterDuplicates(): TPointArray;
begin
  Result := Self.Copy();
  ClearSamePoints(Result);
end;

(*
TPointArray.ClearDuplicates
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    procedure TPointArray.ClearDuplicates();

Removes all the duplicate points from self.
*)
procedure TPointArray.ClearDuplicates();
begin
  ClearSamePoints(Self);
end;

(*
TPointArray.Rotate
~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Rotate(AngleRad, MidX, MidY: Double): TPointArray;

Returns a copy where all points are rotated around MidX, MidY.
Same as Simba's `RotatePoints`.
*)
function TPointArray.Rotate(AngleRad, MidX, MidY: Double): TPointArray; 
begin
  Result := RotatePoints(Self, AngleRad, MidX, MidY);
end;

(*
TPointArray.SplitRows
~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.SplitRows(dist:Int32): T2DPointArray; 

Splits a TPA `Arr` into TPAs of each row, it then proceeds to further split the rows
in to separate TPAs when the given distance ``dist`` is less than the distance between the points
Same output as `SplitTPAEx(TPA,dist,0)`, but generally faster.

.. note:: by slacky

Example:

.. code-block:: pascal

    ATPA := TPA.SplitRows(5);
*)
function TPointArray.SplitRows(dist:Int32): T2DPointArray; 
var
  TPA,tmp:TPointArray;
  i,ii,j,n,s,h,l:Int32 = 0;
begin
  TPA := Self.Copy();
  SortTPAByY(TPA,True);
  Result.SetLength(TPA.Length());
  l := TPA.Length();
  while j < l do
  begin
    s := 0;
    i := j;
    inc(j);
    while (j < l) and (TPA[j].y = TPA[j-1].y) do Inc(j);

    if j-i > 1 then
    begin
      tmp := TPA.Copy(i,j-i);
      SortTPAByX(tmp,True);
      h := tmp.High();
      for ii:=1 to h do
        if (tmp[ii].x-tmp[ii-1].x > dist) or (ii = h) then
        begin
          Result[Inc(n)-1] := tmp.Copy(s, ii-s+(ord(ii = h) and 1));
          s := ii;
        end;
    end else if j-i = 1 then
      Result[Inc(n)-1] := [TPA[i]];
  end;
  Result.SetLength(n);
end;


(*
TPointArray.Connect
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Connect(): TPointArray; 

Fills a line between all the points (by their order), can be used to get the edges
around a polygon

.. note:: by slacky

Example:

.. code-block:: pascal
    
    edges := TPA.ConvexHull().Connect();
*)
function TPointArray.Connect(): TPointArray; 
var line:TPointArray; i:Int32;
begin
  if self.Length() = 0 then Exit;
  
  for i:=0 to self.High()-1 do
  begin
    line := TPAFromLine(self[i].x, self[i].y, self[i+1].x, self[i+1].y);
    Result += line;
  end;
  line := TPAFromLine(self[self.High()].x, self[self.High()].y, self[0].x, self[0].y);
  Result += line;
end;


(*
TPointArray.ConvexHull
~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

     function TPointArray.ConvexHull(): TPointArray; 

Computes the convex hull around the given TPA. Imagine placing a rubber band around the
points, the points which strech the band are the points returned by this function.

See: http://en.wikipedia.org/wiki/Convex_hull for more information.

.. note:: by slacky

Example:

.. code-block:: pascal

    Smart.Image.DrawTPA(TPA.ConvexHull());
*)
function TPointArray.ConvexHull(): TPointArray; 
var
  pts: TPointArray;
  h,i,k,u: Int32;
begin
  if self.High() <= 2 then Exit(self);
  pts := self.Copy();
  SortTPAByX(pts,True);

  H := pts.High();
  result.SetLength(2 * (h+1));

  for i:=0 to h do
  begin
    while (k >= 2) and (srl.CrossProduct(result[k-2], result[k-1], pts[i]) <= 0) do
      Dec(k);
    result[k] := pts[i];
    Inc(k)
  end;

  u := k+1;
  for i:=h-1 downto 0 do
  begin
    while (k >= u) and (srl.CrossProduct(result[k-2], result[k-1], pts[i]) <= 0) do
      Dec(k);
    result[k] := pts[i];
    Inc(k);
  end;
  result.SetLength(k-1);
end;

(*
TPointArray.MinAreaRect
~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.MinAreaRect(): TRectangle;

Computes the minimum bounding box (defined by area) around the given shape.
Four points (which are in order) are always returned.

See: http://en.wikipedia.org/wiki/Minimum_bounding_box for more information.

.. note:: by slacky

Example:

.. code-block:: pascal

    WriteLn('The four box corners are: ', TPA.MinAreaRect());
*)
function TPointArray.MinAreaRect: TQuad;
begin
  Result := TQuad.CreateFromPoints(Self);
end;


(*
TPointArray.MinAreaCircle
~~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.MinAreaCircle(): TCircle;

Computes the minimum bounding circle around the given shape.

See: https://en.wikipedia.org/wiki/Smallest-circle_problem for more information.

Implementation is a mixture of a few implementations I've seen.
*)
function TPointArray.MinAreaCircle(): TCircle; 
  function NewCircle2(p0, p1: TPoint): TCircle;
  var
    x,y: Int32;
  begin
    x := (p0.x + p1.x) div 2;
    y := (p0.y + p1.y) div 2;
    Result := [x,y, Ceil(System.Max(Hypot(x-p0.x,y-p0.y),Hypot(x-p1.x,y-p1.y)))];
  end;

  function NewCircle3(p0, p1, p2: TPoint): TCircle;
  var
    d,ax,ay,bx,by,cx,cy,ox,oy,x,y,ra,rb,rc: Int32;
  begin
    // Mathematical algorithm from Wikipedia: Circumscribed circle
    ax := p0.x; ay := p0.y;
    bx := p1.x; by := p1.y;
    cx := p2.x; cy := p2.y;
    ox := (System.Min(System.Min(ax, bx), cx) + System.Max(System.Max(ax, bx), cx)) div 2;
    oy := (System.Min(System.Min(ay, by), cy) + System.Max(System.Max(ay, by), cy)) div 2;
    ax -= ox; ay -= oy;
    bx -= ox; by -= oy;
    cx -= ox; cy -= oy;
    d := (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) * 2;
    if (d = 0) then
      Exit;
    x := ox + ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) div d;
    y := oy + ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) div d;
    ra := Ceil(Hypot(x-p0.x, y-p0.y));
    rb := Ceil(Hypot(x-p1.x, y-p1.y));
    rc := Ceil(Hypot(x-p2.x, y-p2.y));
    Result := [x,y, System.Max(System.Max(ra, rb), rc)];
  end;

  // Two boundary points known
  function makeCircleTwoPoints(points:TPointArray; p, q: TPoint): TCircle;
  var
    c, circ, left, right: TCircle;
    r: TPoint;
    cross: Double;
  begin
    circ := NewCircle2(p, q);

    // For each point not in the two-point circle
    for r in points do
    begin
      if (circ.Contains(r)) then
        continue;

      // Form a circumcircle and classify it on left or right side
      cross := srl.CrossProduct(p.x, p.y, q.x, q.y, r.x, r.y);
      c := NewCircle3(p, q, r);
      if (c.Radius = 0) then
        continue
      else if (cross > 0) and ((left.Radius = 0) or (srl.CrossProduct(p.x, p.y, q.x, q.y, c.x, c.y) > srl.CrossProduct(p.x, p.y, q.x, q.y, left.x, left.y))) then
        left := c
      else if (cross < 0) and ((right.Radius = 0) or (srl.CrossProduct(p.x, p.y, q.x, q.y, c.x, c.y) < srl.CrossProduct(p.x, p.y, q.x, q.y, right.x, right.y))) then
        right := c;
    end;

    // Select which circle to return
    if (left.Radius = 0) and (right.Radius = 0) then
      Exit(circ)
    else if (left.Radius = 0) then
      Exit(right)
    else if (right.Radius = 0) or (left.Radius <= right.Radius) then
      Exit(left)
    else
      Exit(right);
  end;

  // One boundary point known
  function makeCircleOnePoint(Points:TPointArray; p:TPoint): TCircle;
  var
    i:Int32;
    q:TPoint;
  begin
    Result := [p.x, p.y, 0];
    for i:=0 to Points.High() do
    begin
      q := points[i];
      if (not Result.Contains(q)) then
      begin
        if (Result.Radius = 0) then
          Result := NewCircle2(p, q)
        else
          Result := makeCircleTwoPoints(points.Copy(0, i + 1), p, q);
      end;
    end;
  end;

var
  TPA: TPointArray;
  i: Int32;
  p: TPoint;
begin
  if Self.Length() = 0 then Exit();
  if Self.Length() = 1 then Exit(TCircle([Self[0].x, Self[0].y, 0]));

  // Copy the list and shuffle
  TPA := Self.Copy();
  for i := TPA.High() downto 0 do
    TPA.Swap(i, Random(0,i));
  
  // Add points to circle one by one, and if needed recompute circle
  for i:=0 to TPA.High() do
  begin
    p := TPA[i];
    if (Result.Radius = 0) or (not Result.Contains(p)) then
      Result := makeCircleOnePoint(TPA.Copy(0, i + 1), p);
  end;
end;

(*
TPointArray.Density
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

    function TPointArray.Density(): Double; 

Returns the TPA's density (Length(TPA)/(width*height))
*)
function TPointArray.Density: Double; 
var
  Area: Int32;
begin
  if Self.Length() = 0 then
    Exit;

  Area := Self.MinAreaRect().Expand(1).Area;
  if (Area > 0) then
    Result := Self.Length() / Area;
end;


//--| Other TPA methods |------------------------------------------------------>
//----------------------------------------------------------------------------->
(*
ExpandPolygon
~~~~~~~~~~~~~~

.. code-block:: pascal

    function ExpandPolygon(Poly:TPointArray; inc:Int32): TPointArray;

A method for increasing the size of any convex polygon.

.. note:: by slacky
*)
function ExpandPolygon(Poly: TPointArray; inc: Int32): TPointArray;
type
  TPointF = record x,y:Double; end;
var
  i,k:Int32;
  theta, det: Double;
  c1,c2:array [0..2] of Double;
  p1,q1,p2,q2: TPointF;
  tmp:array of TPointF;
begin
  SetLength(Result, Length(Poly));
  SetLength(tmp, Length(Poly)*2);
  for i:=0 to High(Poly) do
  begin
    k := (i+1) mod Length(poly);
    theta := ArcTan2(poly[i].Y - poly[k].Y, poly[i].X - poly[k].X) + PI/2;
    tmp[i*2]  := TPointF([inc*Cos(theta)+poly[i].x, inc*Sin(theta)+poly[i].y]);
    tmp[i*2+1]:= TPointF([inc*Cos(theta)+poly[k].x, inc*Sin(theta)+poly[k].y]);
  end;

  for i:=0 to High(tmp) with 2 do
  begin
    p1 := tmp[i];
    p2 := tmp[(i+1) mod Length(tmp)];
    q1 := tmp[(i+2) mod Length(tmp)];
    q2 := tmp[(i+3) mod Length(tmp)];

    c1 := [(p1.y-p2.y), (p2.x-p1.x), -(p1.x*p2.y-p2.x*p1.y)];
    c2 := [(q1.y-q2.y), (q2.x-q1.x), -(q1.x*q2.y-q2.x*q1.y)];
    det  := c1[0] * c2[1] - c1[1] * c2[0];
    if (det <> 0) then
    begin
      Result[i div 2].x := Round((c1[2] * c2[1] - c1[1] * c2[2]) / det);
      Result[i div 2].y := Round((c1[0] * c2[2] - c1[2] * c2[0]) / det);
    end else
      Result[i div 2] := Point(Round(p2.x), Round(p2.y));
  end;
end;

function RandomTPA(n:Int32; B:TBox): TPointArray;
var i:Int32;
begin
  SetLength(Result, n);
  for i:=0 to n-1 do
    Result[i] := Point(Random(B.x1,B.x2), Random(B.y1,B.y2));
end;

// -------------------------------------------------------------------------------------
// Legacy methods (should be removed at some point, don't use them)

procedure TPointArray.Fill;
begin
  FillEllipse(Self);
end;

function TPointArray.Grow(constref Amount: Int32): TPointArray; 
begin
  Result := TPAGrow(Self, Amount);
end;

function TPointArray.Erode(constref Amount: Int32): TPointArray; 
begin
  Result := TPAErode(Self, Amount);
end;

(*
TPointArray.PointsInRangeOf
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
  function TPointArray.PointsInRangeOf(constref Other: TPointArray; MinDist, MaxDist: Double): TPointArray; 

Returns all the points from `self` that are within range of any point in `other`.
The parameters `mindist` and `maxdist` determine what "within range" means.
*)
function TPointArray.PointsInRangeOf(constref Other: TPointArray; MinDist, MaxDist: Double): TPointArray;  overload;
begin
  Result := System.PointsInRangeOf(Self, Other, MinDist, MinDist, MaxDist, MaxDist);
end;

(*
TPointArray.PointsInRangeOf
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
  function TPointArray.PointsInRangeOf(constref Other: TPointArray; MinDistX, MinDistY, MaxDistX, MaxDistY: Double): TPointArray;  overload;

Same as the above but lets you specify X- and Y-wise min & max distance separately.
*)
function TPointArray.PointsInRangeOf(constref Other: TPointArray; MinDistX, MinDistY, MaxDistX, MaxDistY: Double): TPointArray;  overload;
begin
  Result := System.PointsInRangeOf(Self, Other, MinDistX, MinDistY, MaxDistX, MaxDistY);
end;

(*
TPointArray.Frameness
~~~~~~~~~~~~~~~~~~~~~
.. pascal::
  function TPointArray.Frameness(): Single;

Idk what this is
*)
function TPointArray.Frameness(): Single;
var
  Edge: TPointArray := EdgeFromBox(Self.Bounds());
begin
  Result := (Edge.PointsInRangeOf(Self, 0, 1).Length() / Edge.Length()) * 100;
end;

function T2DPointArray.Combine(Other: T2DPointArray): T2DPointArray; 
begin
  Result.SetLength(Self.Length() + Other.Length());
  if self.Length() > 0 then
    MemMove(self[0], result[0], self.Length()*SizeOf(self[0]));
  if Other.Length() > 0 then
    MemMove(Other[0], result[Self.Length()], Other.Length()*SizeOf(Other[0]));
end;

function T2DPointArray.Merge(): TPointArray; 
begin
  Result := MergeATPA(self);
end;

procedure T2DPointArray.FilterSize(MinLen:Int32; KeepIf:EComparator=__LT__);
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    case KeepIf of
      __LT__: if TPA.Length() < MinLen then tmp += TPA;
      __GT__: if TPA.Length() > MinLen then tmp += TPA;
      __EQ__: if TPA.Length() = MinLen then tmp += TPA;
      __NE__: if TPA.Length()<> MinLen then tmp += TPA;
    end;
  self := tmp;
end;

procedure T2DPointArray.FilterSize(MinLen,MaxLen:Int32); overload;
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    if InRange(TPA.Length(), MinLen, MaxLen) then
      tmp += TPA;
  self := tmp;
end;

procedure T2DPointArray.FilterDimensions(MinW, MinH: Int32; MaxW: Int32 = $FFFFFF; MaxH: Int32 = $FFFFFF);
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    with GetTPABounds(TPA) do
      if InRange(x2-x1+1, MinW, MaxW) and InRange(y2-y1+1, MinH, MaxH) then
        tmp += TPA;
  self := tmp;
end;

procedure T2DPointArray.SortByMiddle(From: TPoint);
begin
  SortATPAFromMidPoint(Self, From);
end;

procedure T2DPointArray.SortByIndex(From: TPoint; Index:Int32=0);
var
  i: Int32;
  weights: TIntegerArray;
begin
  if (self.Length() <= 1) then Exit;
  weights.SetLength(self.Length());
  for i:=0 to self.High() do
  begin
    if Self[i].Length() = 0 then continue;
    weights[i] := Round(Sqr(From.x - self[i][Index].x) + Sqr(From.y - self[i][Index].y));
  end;
  Self.Sort(weights, True);
end;

procedure T2DPointArray.SortBySize(Size:Int32=0; ClosestFirst: Boolean=False);
begin
  SortATPAFromSize(Self, Size, ClosestFirst);
end;

procedure T2DPointArray.SortByArea(LowToHi: Boolean = False);
var
  i: Int32;
  weights: TIntegerArray;
begin
  if (self.Length() <= 1) then Exit;
  weights.SetLength(self.Length());
  for i:=0 to self.High() do
  begin
    if Self[i].Length() = 0 then
      Continue;
    weights[i] := Self[i].MinAreaRect.Area;
  end;
  Self.Sort(weights, LowToHi);
end;

procedure T2DPointArray.SortByLongSide(LowToHi: Boolean = False);
var
  i, Long, Short: Int32;
  weights: TIntegerArray;
begin
  if (self.Length() <= 1) then Exit;
  weights.SetLength(self.Length());
  for i:=0 to self.High() do
  begin
    if Self[i].Length() = 0 then
      Continue;
    weights[i] := Self[i].MinAreaRect().LongSideLen;
  end;
  Self.Sort(weights, LowToHi);
end;

procedure T2DPointArray.SortByDensity(LowToHi: Boolean = False);
var
  i: Int32;
  weights: TIntegerArray;
begin
  if (self.Length() <= 1) then Exit;
  weights.SetLength(self.Length());
  for i:=0 to self.High() do
  begin
    if Self[i].Length() = 0 then
      Continue;

    weights[i] := Round(Self[i].Density * 100);
  end;
  Self.Sort(weights, LowToHi);
end;

procedure T2DPointArray.SortByX(LowToHi: Boolean = True);
var
  Weights: TIntegerArray;
  I: Int32;
begin
  if Self.Length() = 0 then
    Exit;

  Weights.SetLength(Self.Length());
  for I := 0 to Weights.High() do
    Weights[I] := Self[I].Bounds.X1;

  Self.Sort(weights, LowToHi);
end;

procedure T2DPointArray.SortByY(LowToHi: Boolean = True);
var
  Weights: TIntegerArray;
  I: Int32;
begin
  if Self.Length() = 0 then
    Exit;

  Weights.SetLength(Self.Length());
  for I := 0 to Weights.High() do
    Weights[I] := Self[I].Bounds.Y1;

  Self.Sort(weights, LowToHi);
end;

function T2DPointArray.Means(): TPointArray; 
var i:Int32;
begin
  Result.SetLength(self.Length());
  for i:=0 to Self.High() do
    Result[i] := MiddleTPA(Self[i]);
end;

function T2DPointArray.ToTBA(): TBoxArray; 
var i:Int32;
begin
  Result.SetLength(self.Length());
  for i:=0 to Self.High() do
    Result[i] := GetTPABounds(Self[i]);
end;

function T2DPointArray.Smallest(): TPointArray; 
var
  TPA: TPointArray;
begin
  for TPA in Self do
    if (TPA.Length() < Result.Length()) then
      Result := TPA;
end;

function T2DPointArray.Biggest(): TPointArray; 
var
  TPA: TPointArray;
begin
  for TPA in Self do
    if (TPA.Length() > Result.Length()) then
      Result := TPA;
end;
