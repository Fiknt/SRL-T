{$DEFINE SRL_MM2MS_PROJECTOR_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TMM2MSProjector = record(TSRLBaseRecord)
  class const
    FIXED_Y_LOOK = -25.5;
    FIXED_SCALE_MIN = 0.80;
    FIXED_SCALE_MAX = 6.32;

    RESIZABLE_Y_LOOK = -21;
    RESIZABLE_SCALE_MIN = 0.635;
    RESIZABLE_SCALE_MAX = 4.90;
  end;

// OSRS zooms at a non standard value for this projector
// This curve figures it out (credit: slacky)
// The best solution would be to adjust the projector to work at this curve without so much WTF.
function TMM2MSProjector.GetZoomValue(level: Integer): Single; static;
var
  x,y,p: Single;
begin
  y := 1 - (Ln(100-level+2.5)-Ln(2.5)) / (Ln(100+2.5)-Ln(2.5));
  x := 1 - (Ln(100-level/1.32)-Ln(100-100/1.32)) / (Ln(100)-Ln(100-100/1.32));
  p := level/100;
  Result := x * (p) + y * (1-p);
end;

function TMM2MSProjector.Run(Coords: Vector3Array; Rotation: Vector3; ClientMode: ERSClientMode; ZoomLevel: Integer): TPointArray; static; overload;
const
  SQRT_2 := Sqrt(2);
var
  Scale, Zoom: Single;
  ViewMatrix, ProjMatrix, WorldMatrix, TransMatrix: TMatrix4;
  MainScreenMiddle: TPoint;
  MainScreenHeight: Integer;

  function Transform(Coord: Vector3; Matrix: TMatrix4): Vector3;
  var
    P: Vector3;
  begin
    P := Vector3.TransformCoordinate(Coord, Matrix);
    Result.X := (+P.X * 513 * Scale) + MainScreenMiddle.X;
    Result.Y := (-P.Y * 335 * Scale) + MainScreenMiddle.Y + (Zoom * 24); // y shift
  end;

var
  I: Int32;
  ScaleMin, ScaleMax: Single;
begin
  Zoom := Self.GetZoomValue(ZoomLevel);

  case ClientMode of
    ERSClientMode.FIXED:
      begin
        MainScreenMiddle := [260, 171];
        MainScreenHeight := 334;

        ScaleMin := Self.FIXED_SCALE_MIN * MainScreenHeight / 503;
        ScaleMax := Self.FIXED_SCALE_MAX * MainScreenHeight / 503;
        Scale    := ScaleMin + Zoom * (ScaleMax - ScaleMin);

        ViewMatrix  := TMatrix4.LookAtRH([0, Self.FIXED_Y_LOOK, 61], [0, 0, 1.3], Vector3_UnitY);
        ProjMatrix  := TMatrix4.PerspectiveFovRH(SQRT_2, 765 / 503, 0.01, 1.0);
        WorldMatrix := TMatrix4.RotationYawPitchRoll(Rotation.Y, Rotation.X, Rotation.Z) * Matrix_Identity;
        TransMatrix := WorldMatrix * ViewMatrix * ProjMatrix;
      end;

    ERSClientMode.RESIZABLE_MODERN, ERSClientMode.RESIZABLE_CLASSIC:
      begin
        MainScreenMiddle := MainScreen.Center;
        MainScreenHeight := MainScreen.Height;

        ScaleMin := Self.RESIZABLE_SCALE_MIN * MainScreenHeight / 503;
        ScaleMax := Self.RESIZABLE_SCALE_MAX * MainScreenHeight / 503;
        Scale    := ScaleMin + Zoom * (ScaleMax - ScaleMin);

        ViewMatrix  := TMatrix4.LookAtRH([0, Self.RESIZABLE_Y_LOOK, 61], [0, 0, 1.3], Vector3_UnitY);
        ProjMatrix  := TMatrix4.PerspectiveFovRH(SQRT_2, 765 / 503, 0.01, 1.0);
        WorldMatrix := TMatrix4.RotationYawPitchRoll(Rotation.Y, Rotation.X, Rotation.Z) * Matrix_Identity;
        TransMatrix := WorldMatrix * ViewMatrix * ProjMatrix;
      end;
  end;

  SetLength(Result, Length(Coords));

  for I := 0 to High(Coords) do
    with Transform(Coords[I], TransMatrix) do
    begin
      Result[I].X := Round(X);
      Result[I].Y := Round(Y);
    end;
end;

function TMM2MSProjector.Run(Coord: Vector3; Rotation: Vector3; ClientMode: ERSClientMode; ZoomLevel: Integer): TPoint; static; overload;
begin
  Result := Self.Run([Coord], Rotation, ClientMode, ZoomLevel)[0];
end;
