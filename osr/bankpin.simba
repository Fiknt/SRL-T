{$DEFINE SRL_BANKPIN_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSBankPin = record(TRSInterface)
  class const
    ELEMENT_BUTTON_0: TRSInterfaceElement = [21, 83, 64, 64];
    ELEMENT_BUTTON_1: TRSInterfaceElement = [115, 83, 64, 64];
    ELEMENT_BUTTON_2: TRSInterfaceElement = [210, 83, 64, 64];
    ELEMENT_BUTTON_3: TRSInterfaceElement = [293, 83, 64, 64];
    ELEMENT_BUTTON_4: TRSInterfaceElement = [21, 155, 64, 64];
    ELEMENT_BUTTON_5: TRSInterfaceElement = [115, 155, 64, 64];
    ELEMENT_BUTTON_6: TRSInterfaceElement = [209, 155, 64, 64];
    ELEMENT_BUTTON_7: TRSInterfaceElement = [21, 227, 64, 64];
    ELEMENT_BUTTON_8: TRSInterfaceElement = [115, 227, 64, 64];
    ELEMENT_BUTTON_9: TRSInterfaceElement = [209, 227, 64, 64];
    ELEMENT_EXIT:     TRSInterfaceElement = [374, 230, 32, 17];
    ELEMENT_STATE:    TRSInterfaceElement = [147, 57, 204, 22];
  var
    Entering: Boolean;
  end;

function TRSBankPin.IsOpen: Boolean;
begin
  Result := Self.ElementFinder.HasText(Self.ELEMENT_EXIT, [RSColors.TEXT_WHITE, RSColors.TEXT_RED], 'Exit', RS_FONT_QUILL_8);
end;

procedure TRSBankPin.Setup(Name: String); override;
begin
  inherited;

  with Self.BoundsFinder.Alignments[ERSClientMode.FIXED] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 11];
    Bottom := [@InterfaceArea.Y2];

    Center.MaxWidth  := 488;
    Center.MaxHeight := 305;
  end;

  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 10];
    Bottom := [@InterfaceArea.Y2];

    Center.MaxWidth  := 488;
    Center.MaxHeight := 305;
  end;

  // Same as above
  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_MODERN] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 10];
    Bottom := [@InterfaceArea.Y2];

    Center.MaxWidth  := 488;
    Center.MaxHeight := 305;
  end;
end;

function TRSBankPin.Enter(Pin: String; IsNextInterfaceOpen: function: Boolean of object): Boolean;

  function GetDigitToEnter: Integer;
  begin
    if Self.ElementFinder.HasText(Self.ELEMENT_STATE, [RSColors.TEXT_WHITE], 'FIRST', RS_FONT_BOLD_12)  then Exit(1);
    if Self.ElementFinder.HasText(Self.ELEMENT_STATE, [RSColors.TEXT_WHITE], 'SECOND', RS_FONT_BOLD_12) then Exit(2);
    if Self.ElementFinder.HasText(Self.ELEMENT_STATE, [RSColors.TEXT_WHITE], 'THIRD', RS_FONT_BOLD_12)  then Exit(3);
    if Self.ElementFinder.HasText(Self.ELEMENT_STATE, [RSColors.TEXT_WHITE], 'FOURTH', RS_FONT_BOLD_12) then Exit(4);
  end;

  function ClickDigit(Digit: Char): Boolean;
  var
    Buttons: TRSInterfaceElementArray;
    Button: TRSInterfaceElement;
  begin
    Buttons := [
      Self.ELEMENT_BUTTON_0, Self.ELEMENT_BUTTON_1, Self.ELEMENT_BUTTON_2,
      Self.ELEMENT_BUTTON_3, Self.ELEMENT_BUTTON_4, Self.ELEMENT_BUTTON_5,
      Self.ELEMENT_BUTTON_6, Self.ELEMENT_BUTTON_7, Self.ELEMENT_BUTTON_8,
      Self.ELEMENT_BUTTON_9
    ];
    for Button in Buttons do
      if Self.ElementFinder.HasText(Button, [$007FFF], Digit, RS_FONT_BOLD_12) then
      begin
        Self.ElementFinder.Click(Button);

        Exit(True);
      end;
  end;

  function EnterDigit(Digit: Char): Boolean;
  begin
    if WaitUntil(ClickDigit(Digit), 100, RandomLeft(1000, 2000)) then
      Exit(True);

    // Likely hovering the button but mouse away to make sure.
    if Mouse.Position() in Self.Bounds() then
    begin
      with Self.Bounds().Invert(Self.Bounds().Expand(50)) do
        Mouse.Move(RandomValue());
      Result := ClickDigit(Digit);
    end;
  end;

var
  Digit: Int32;
begin
  Self.Entering := True;

  try
    while Self.IsOpen() do
    begin
      Digit := GetDigitToEnter();

      if (Digit > 0) then
      begin
        if EnterDigit(Pin[Digit]) then
        begin
          case Digit of
            1,2,3:
              begin
                if not WaitUntil(GetDigitToEnter() > Digit, 500, 2500 + Random(1000)) then
                  Self.DebugLn('Failed to progress to next digit');
              end;
            4:
              begin
                if WaitUntil(IsNextInterfaceOpen(), 500, 2500 + Random(1000)) then
                  Exit(True);

                Self.DebugLn('Failed to progress to next interface');
              end;
          end;
        end;
      end;

      Wait(0, 1500, wdLeft);
    end;

    Result := IsNextInterfaceOpen();
    if Result then
      Self.DebugLn('Progressed to interface somehow!');
  finally
    Self.Entering := False;
  end;
end;

var
  BankPin: TRSBankPin;

begin
  BankPin.Setup('BankPin');
end;

(*
TRSBank.IsOpen
~~~~~~~~~~~~~~
.. pascal:: function TRSBank.IsOpen: Boolean; override;
Overrides **Bank.IsOpen** to handle pin.
*)
function TRSBank.IsOpen: Boolean; override;
begin
  if inherited() then
    Exit(True);

  if (not BankPin.Entering) and BankPin.IsOpen()then
  begin
    Self.DebugLn('Entering bankpin...');

    Result := BankPin.Enter(Login.GetPlayerPin(), @Bank.IsOpen);
    if not Result then
      Self.Fatal('Failed to enter bank pin');
  end;
end;

(*
TRSGrandExchange.IsOpen
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSGrandExchange.IsOpen: Boolean; override;
Overrides **GrandExchange.IsOpen** to handle pin.
*)
//function TRSGrandExchange.IsOpen: Boolean; override;
//begin
//  if Result := inherited() then
//    Exit(True);
//
//  if (not BankPin.Entering) and BankPin.IsOpen()then
//  begin
//    Result := BankPin.Enter(Login.GetPlayerPin(), @GrandExchange.IsOpen);
//    if not Result then
//      Self.Fatal('Failed to enter bank pin');
//  end;
//end;
