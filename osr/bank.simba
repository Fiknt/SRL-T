(*
Bank
====
Methods to interact with the Bank.
*)

{$DEFINE SRL_BANK_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

const
  BANK_DEPOSIT_ALL          = -1;
  
  BANK_WITHDRAW_ALL         = -1;
  BANK_WITHDRAW_ALL_BUT_ONE = -2;
  
type
  ERSBankLocation = (
    CASTLE_WARS,
    FEROX,
    GRAND_EXCHANGE,
    FALADOR_EAST
  );

  TRSBankWithdrawItem = record
    Item: TRSItem;
    Quantity: Int32;
    Noted: Boolean;
  end;
  
  TRSBankWithdrawSlot = record
    Slot: Int32;
    Quantity: Int32;
    Noted: Boolean;
  end;
  
  TRSBankDepositItem = record
    Item: TRSItem;
    Quantity: Int32;
  end;
  
  TRSBankDepositSlot = record
    Slot: Int32;
    Quantity: Int32;
  end;
  
  TRSBank = record(TRSInterface)
  class const
    ELEMENT_TAB_0:             TRSInterfaceElement = [46, 37, 33, 38];
    ELEMENT_TAB_1:             TRSInterfaceElement = [86, 37, 33, 38];
    ELEMENT_TAB_2:             TRSInterfaceElement = [126, 37, 33, 38];
    ELEMENT_TAB_3:             TRSInterfaceElement = [166, 37, 33, 38];
    ELEMENT_TAB_4:             TRSInterfaceElement = [206, 37, 33, 38];
    ELEMENT_TAB_5:             TRSInterfaceElement = [246, 37, 33, 38];
    ELEMENT_TAB_6:             TRSInterfaceElement = [286, 37, 33, 38];
    ELEMENT_TAB_7:             TRSInterfaceElement = [326, 37, 33, 38];
    ELEMENT_TAB_8:             TRSInterfaceElement = [366, 37, 33, 38];
    ELEMENT_TAB_9:             TRSInterfaceElement = [406, 37, 33, 38];

    ELEMENT_SWAP:              TRSInterfaceElement = [5, 5, 50, 22,   ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_INSERT:            TRSInterfaceElement = [55, 5, 50, 22,  ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_ITEM:              TRSInterfaceElement = [105, 5, 50, 22, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_NOTE:              TRSInterfaceElement = [155, 5, 50, 22, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_QUANTITY_1:        TRSInterfaceElement = [205, 5, 25, 22, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_QUANTITY_5:        TRSInterfaceElement = [230, 5, 25, 22, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_QUANTITY_10:       TRSInterfaceElement = [255, 5, 25, 22, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_QUANTITY_X:        TRSInterfaceElement = [280, 5, 25, 22, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_QUANTITY_ALL:      TRSInterfaceElement = [305, 5, 25, 22, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_SEARCH:            TRSInterfaceElement = [370, 6, 36, 36, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_DEPOSIT_INVENTORY: TRSInterfaceElement = [409, 6, 36, 36, ERSInterfaceElementAnchor.BOTTOM];
    ELEMENT_DEPOSIT_WORN:      TRSInterfaceElement = [446, 6, 36, 36, ERSInterfaceElementAnchor.BOTTOM];

    FINDER_UPTEXT: TStringArray = ['to-Bank', 'Banker', 'Bank booth', 'Bank bank'];
    FINDER_OPTION: TStringArray = ['Bank Banker', 'Bank Bank booth'];
  end;

function TRSBank.FindItem(Item: TRSItem; out Box: TBox): Boolean;
begin
  Result := Self.ItemFinder.Find([Item], Box);
end;

function TRSBank.MouseItem(Item: TRSItem): Boolean;
begin
  Result := Self.ItemFinder.Mouse(Item);
end;

function TRSBank.ClickItem(Item: TRSItem): Boolean;
begin
  Result := Self.ItemFinder.Click(Item);
end;

function TRSBank.InteractItem(Item: TRSItem; Option: String): Boolean;
begin
  Result := Self.ItemFinder.Interact(Item, Option);
end;

function TRSBank.ContainsItem(Item: TRSItem): Boolean; overload;
begin
  Result := Self.ItemFinder.Contains(Item);
end;

function TRSBank.ContainsItem(Items: TRSItemArray): Boolean; overload;
begin
  Result := Self.ItemFinder.ContainsAny(Items);
end;

function TRSBank.ContainsAllItems(Items: TRSItemArray): Boolean;
begin
  Result := Self.ItemFinder.ContainsAll(Items);
end;

function TRSBank.CountItemStack(Item: TRSItem): Integer;
begin
  Result := Self.ItemFinder.CountStack(Item);
end;

function TRSBank.GetItemArea: TBox;
begin
  Result := Self.Bounds;
  Result.X1 += 57;
  Result.Y1 += 77;
  Result.X2 -= 62;
  Result.Y2 -= 43;
end;

function TRSBank.GetSlotBoxes: TBoxArray;
begin
  with Self.GetItemArea() do
    Result := TBoxArray.Create([X1, Y1], 8, Height() div 35, 31, 31, [17, 5]);
end;

(*
TRSBank.HasItems
~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.HasItems: Boolean;

Returns True if the bank has items.
Uses the black item border to determines if items exist.
*)
function TRSBank.HasItems: Boolean;
begin
  Result := SRL.CountColor(RSColors.ITEM_BORDER, Self.GetItemArea()) > 0;
end;

(*
Bank.IsOpen
~~~~~~~~~~~
.. pascal:: function TRSBank.IsOpen: Boolean;

Returns true if the bank screen is open.
*)
function TRSBank.IsOpen: Boolean; overload;
begin
  Result := Self.IsTitle('Bank') or Self.IsTitle('Tab') or Self.IsTitle('Showing') or Self.IsTitle('Equip');
end;

function TRSBank.IsOpen(WaitTime: Int32; Interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  Result := WaitUntil(Self.IsOpen(), Interval, WaitTime);
end;

(*
Bank.Close
~~~~~~~~~~
.. pascal:: function TRSBank.Close(PressEscape: Boolean = False): Boolean;

Closes the bank, Depending on `PressEscape` the function will either click the button
or press backspace.

Example
-------

 WriteLn Bank.Close();
*)
function TRSBank.Close(PressEscape: Boolean = False): Boolean; 
begin
  if not Self.IsOpen() then
    Exit(True);

  Result := Self.ClickCloseButton(PressEscape) and WaitUntil(not Self.IsOpen(), SRL.TruncatedGauss(50, 1500), Random(1500, 2000));
end;

procedure TRSBank.Draw(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen() then
    Exit;

  inherited;

  {
  Bitmap.DrawButtons(Self.GetButtons());
  Bitmap.DrawBoxArray(Self.GetTabBoxes(), False, $00FFFF);
  Bitmap.DrawBoxArray(Self.GetSlotBoxes(), False, $00FFFF);
  }
end;

function TRSBank.IsSearching: Boolean;
begin
  Result := Self.IsTitle('Showing items');
end;

(*
Bank.CloseSearch
~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.CloseSearch: Boolean;

Closes the bank search if it's open.

Example
-------

  Bank.Search('logs'); // Search for logs
  Wait(1000);
  Bank.CloseSearch();
*)
function TRSBank.CloseSearch: Boolean;
begin
  if (not Self.IsSearching()) then
    Exit(True);

  Result := Self.ElementFinder.Toggle(Self.ELEMENT_SEARCH, RSColors.BUTTON_GREY, 5) and WaitUntil(not Self.IsSearching(), 100, Random(1000, 2000));
end;

function TRSBank.OpenSearch: Boolean;
begin
  if Self.IsSearching() then
    Exit(True);

  Result := Self.ElementFinder.Toggle(Self.ELEMENT_SEARCH, RSColors.BUTTON_RED, 5) and WaitUntil(Self.IsSearching(), 100, Random(1000, 2000));
end;

(*
Bank.Search
~~~~~~~~~~~
.. pascal:: function TRSBank.Search(Item: String): Boolean;

Searches for an item.

Example
-------

  Bank.Search('logs'); // Search for logs
*)
function TRSBank.Search(Item: String): Boolean; 

  function IsSearchingItem: Boolean;
  begin
    Result := Self.IsTitle('Showing items: ' + LowerCase(Item));
  end;

begin
  if IsSearchingItem() then
    Exit(True);

  Result := Self.CloseSearch() and  Self.OpenSearch() and
            Chat.AnswerQuery('Show items', Item, Random(2000, 2500)) and WaitUntil(IsSearchingItem(), 100, Random(2000, 3000));
end;

(*
Bank.FindItemBoundaries
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.FindItemBoundaries: TBoxArray;

Finds item boundaries. This is an internal function used to retrieve the boxes we
search for items in.

Example
-------
  
  Boxes := Self.FindItemBoundaries();
  WriteLn ItemFinder.Find(Item, Boxes);
*)
function TRSBank.FindItemBoundaries: TBoxArray;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
  Area, B: TBox;
begin
  Area := Self.GetSlotBoxes().Merge();
  
  if SRL.FindColors(TPA, RS_ITEM_BORDER, Area) > 0 then
  begin
    ATPA := TPA.Cluster(50, 3);
    
    for B in ATPA.ToTBA() do
    begin
      if B.Height() <= 5 then
        Continue;
        
      Result += TBoxArray.Create([Area.X1, B.Y1 - 1], 8, 1, 32, 32, [16]);
    end;
  end;
end;

(*
Bank.Open
~~~~~~~~~
.. pascal:: function TRSBank.Open(P: TPoint): Boolean;

Function to open a bank at a specified **P** TPoint.
This function will move the mouse to **P** and if the uptext matches the bank or a banker uptext it will open the bank.

Example
-------
  
  P := CustomBankFinderFunction();
  Bank.Open(P);
*)
function TRSBank.Open(P: TPoint): Boolean;
begin
  Mouse.Move(P);

  Result := ChooseOption.IsOpen() and ChooseOption.Select(Self.FINDER_OPTION);

  if not Result then
  begin
    if MainScreen.IsUpText(Self.FINDER_UPTEXT) then
    begin
      if ('Banker' in MainScreen.GetUpText()) or SRL.Dice(10) then
        Result := ChooseOption.Select(Self.FINDER_OPTION)
      else
      begin
        Mouse.Click(MOUSE_LEFT);

        Result := MainScreen.DidRedClick();
      end;
    end;
  end;

  if Result then
  begin
    if Minimap.HasFlag(Random(200, 400)) then
      Minimap.WaitFlag();

    Result := Self.IsOpen(Random(3000, 4000));
  end;
end;

function TRSBank._FindFaladorEast: T2DPointArray;
var
  Finder: TRSObjectFinder;
begin
  Finder.Colors += CTS2(4086642, 5, 0.08, 0.55);
  Finder.ClusterDistance := 15;
  Finder.Erode := 2;
  Finder.Grow := 3;

  Result := MainScreen.FindObject(Finder);
  if Length(Result) = 0 then
    Exit;

  Result.SortByLongSide();
  Result := Result[0].Cluster(5);
  Result.SortByMiddle(Result.Merge.Mean());
end;

function TRSBank._FindCastleWars: T2DPointArray;
var
  TPA, ChestTPA: TPointArray;
  ATPA: T2DPointArray;
  I: Int32;
begin
  if SRL.FindColors(TPA, CTS2(5526875, 35, 0.19, 0.06), MainScreen.Bounds) > 0 then
  begin
    ATPA := TPA.Cluster(1);

    for I := 0 to High(ATPA) do
      if SRL.FindColors(TPA, CTS2(2503237, 40, 0.10, 0.14), ATPA[I].Bounds) > 5 then
      begin
        TPA := ATPA[I].MinAreaRect.Filter(TPA);
        TPA := TPA.Erode(MainScreen.NormalizeDistance(3));
        if Length(TPA) > 0 then
          ChestTPA += TPA;
      end;

    Result := ChestTPA.Cluster(2);
  end;
end;

function TRSBank._FindFerox: T2DPointArray;
var
  Finder: TRSObjectFinder;
begin
  Finder.Colors += CTS2(931652, 12, 0.07, 0.89);
  Finder.ClusterDistance := 1;
  Finder.Erode := 1;

  Result := MainScreen.FindObject(Finder);
end;

function TRSBank._FindWintertodt: T2DPointArray;
var
  Finder: TRSObjectFinder;
begin
  Finder.ColorClusters += [
    CTS2(3289384, 4, 0.51, 0.37),  //Dark hole
    CTS2(13025214, 17, 0.13, 0.11), //Snow color
    10
  ];

  Finder.ClusterDistance := 2;
  Finder.Grow := 3;
  Finder.Erode := 2;

  Result := MainScreen.FindObject(Finder);
  if Length(Result) = 0 then
    Exit;
  Result.SortByLongSide();
  Result := Result[0].Cluster(3);
  Result.SortByMiddle(Result.Merge.Mean());
end;

(*
Bank._SimplifyItemName
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank._SimplifyItemName(Item: TRSItem): String;

Internal function to get a human like search term for an item.
This could be improved for better antiban but I decided to keep it simple since it's not used very frequently.
This basically strips the item name from things humans won't usually type when searching, like brackets. It also makes the string lower case because people searching don't usually care about casing.
Once that's done wee crop some characters from the final string, because humans don't usually search the full item name, but just enough until it's seen on screen.

.. note:: Could be improved to in the future for only using the relevant part of the string. For example, an human searching for 'Amulet of glory(6)' would probably search for 'glory' instead of 'amulet of gl'.

Example
-------
  
  WriteLn Bank._SimplifyItemName('Amulet of glory(6)');
*)
function TRSBank._SimplifyItemName(Item: TRSItem): String;
var
  ItemStr: String;
  MaxLength, MinLength: Int32;
begin
  ItemStr := ToStr(Item).ToLower();

  if ItemStr.Contains('(') then
    ItemStr := ItemStr.Before('(');

  MaxLength := ItemStr.Length();
  MinLength := MaxLength - Round(MaxLength/3);

  Result := Copy(ItemStr, 0, Random(MinLength, MaxLength));
end;

(*
Bank.FindItemTab
~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.FindItemTab(Item: TRSItem; OpenTab: Boolean = True): Int32;

Find the bank tab of an item just by knowing it's name.
This is very useful when you want to support people having items in any tab they want without much hassle for people to setup.
By default it will open the banktab if the item is found. This can be changed by setting **OpenTab** to false.
The result will be the BankTab of the item. **-1** means we didn't find a BankTab.

.. note:: A known limitation of this is that if several items match the sprite of the item (for example multiple charged jewelry) the tab retrieved will be the first one found. If you have 'Games necklace(1)' in tab 1 and 'Games necklace(8)' in tab 5 and search for the latter, you will get tab 1.

Example
-------
  
  WriteLn Bank.FindItemTab('Molten glass');
*)
function TRSBank.FindItemTab(Item: TRSItem; OpenTab: Boolean = True): Integer;
var
  ItemBox, SearchBox, TextBox: TBox;
  I: Integer;
begin
  if (not Self.Search(Self._SimplifyItemName(Item)) or (not Self.FindItem(Item, ItemBox))) then
    Exit(-1);

  SearchBox := Self.GetItemArea();
  SearchBox.X2 := ItemBox.X2;
  SearchBox.Y2 := ItemBox.Y2;

  for I := 9 downto 1 do
    if (OCR.LocateText(SearchBox, 'Tab ' + ToStr(I), RS_FONT_PLAIN_11, TextBox) = 1) then
    begin
      Result := I;
      if OpenTab then
        Self.OpenTab(Result);

      Exit;
    end;

  Result := 0;
end;

function TRSBank.Open(Location: ERSBankLocation): Boolean; overload;
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  P: TPoint;
begin
  if Self.IsOpen() or Self.Open(Mouse.Position()) then
    Exit(True);
    
  case Location of
    ERSBankLocation.FALADOR_EAST:   ATPA := Self._FindFaladorEast();
    ERSBankLocation.CASTLE_WARS:    ATPA := Self._FindCastleWars();
    ERSBankLocation.FEROX:          ATPA := Self._FindFerox();
  end;

  ATPA.SortBySize();
  if Length(ATPA) > 3 then
    SetLength(ATPA, 3);

  for TPA in ATPA do
  begin
    P := TPA[Random(Length(TPA))];
    P.X += Random(-2, 2);
    P.Y += Random(-2, 2);

    if Self.Open(P) then
      Exit(True);
  end;
end;

function TRSBank.Hover(Location: ERSBankLocation; HoverOption: Boolean): Boolean;
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  P: TPoint;
begin
  if ChooseOption.IsOpen() or MainScreen.IsUpText(Self.FINDER_UPTEXT) then
    Exit(True);

  case Location of
    ERSBankLocation.FALADOR_EAST:   ATPA := Self._FindFaladorEast();
    ERSBankLocation.CASTLE_WARS:    ATPA := Self._FindCastleWars();
    ERSBankLocation.FEROX:          ATPA := Self._FindFerox();
  end;

  ATPA.SortBySize();
  if Length(ATPA) > 3 then
    SetLength(ATPA, 3);

  for TPA in ATPA do
  begin
    P := TPA[Random(Length(TPA))];
    P.X += Random(-2, 2);
    P.Y += Random(-2, 2);

    Mouse.Move(P);
    if MainScreen.IsUpText(Self.FINDER_UPTEXT) then
    begin
      if HoverOption then
        ChooseOption.Hover(['Use Bank', 'Bank Bank']);

      Exit(True);
    end;
  end;
end;

function TRSBank.IsCustomQuantity(Quantity: Int32): Boolean;
begin
  Result := not (Quantity in [1,5,10,BANK_DEPOSIT_ALL]);
end;

function TRSBank.DepositHelper(B: TBox; Amount: Int32; UseQuantityButtons: Boolean): Boolean;
begin
  if UseQuantityButtons then
  begin
    if Self.IsCustomQuantity(Amount) then
    begin
      if not Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_X, RSColors.BUTTON_RED, 5) then
        Exit;

      Mouse.Move(B);

      if Result := MainScreen.IsUpText('Deposit-' + ToString(Amount)) then
        Mouse.Click(MOUSE_LEFT)
      else
        Result := (ChooseOption.Select('Deposit-' + ToString(Amount), MOUSE_LEFT, True, False)) or
                  (ChooseOption.Select('Deposit-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000)));
    end else
    begin
      case Amount of
        1:  Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_1, RSColors.BUTTON_RED, 5);
        5:  Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_5, RSColors.BUTTON_RED, 5);
        10: Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_10, RSColors.BUTTON_RED, 5);
        else
            Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_ALL, RSColors.BUTTON_RED, 5);
      end;

      if Result then
        Mouse.Click(B, MOUSE_LEFT);
    end;
  end else
  begin
    Mouse.Move(B);

    if (Amount = BANK_DEPOSIT_ALL) then
      Result := ChooseOption.Select('Deposit-All')
    else
      Result := ChooseOption.Select('Deposit-' + ToString(Amount) + ' ', MOUSE_LEFT, True, False) or
                ChooseOption.Select('Deposit-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 2500));
  end;
end;

function TRSBank.WithdrawHelper(B: TBox; Amount: Int32; Noted: Boolean; UseQuantityButtons: Boolean): Boolean;
begin
  case Noted of
    True:  if (not Self.ElementFinder.Toggle(Self.ELEMENT_NOTE, RSColors.BUTTON_RED, 5)) then Exit;
    False: if (not Self.ElementFinder.Toggle(Self.ELEMENT_ITEM, RSColors.BUTTON_RED, 5)) then Exit;
  end;

  if UseQuantityButtons then
  begin
    if Self.IsCustomQuantity(Amount) then
    begin
      if not Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_X, RSColors.BUTTON_RED, 5) then
        Exit;

      Mouse.Move(B);

      if Result := MainScreen.IsUpText('Withdraw-' + ToString(Amount)) then
        Mouse.Click(MOUSE_LEFT)
      else
        Result := (ChooseOption.Select('Withdraw-' + ToString(Amount), MOUSE_LEFT, True, False)) or
                  (ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000)));
    end else
    begin
      case Amount of
        1:  Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_1, RSColors.BUTTON_RED, 5);
        5:  Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_5, RSColors.BUTTON_RED, 5);
        10: Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_10, RSColors.BUTTON_RED, 5);
        else
            Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_ALL, RSColors.BUTTON_RED, 5);
      end;

      if Result then
        Mouse.Click(B, MOUSE_LEFT);
    end;
  end else
  begin
    Mouse.Move(B);

    case Amount of
      BANK_WITHDRAW_ALL:
        Result := ChooseOption.Select('Withdraw-All');
      BANK_WITHDRAW_ALL_BUT_ONE:
        Result := ChooseOption.Select('Withdraw-All-but-1');
      else
        Result := (ChooseOption.Select('Withdraw-' + ToString(Amount) + ' ', MOUSE_LEFT, True, False)) or
                  (ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 2500)));
    end;
  end;
end;

(*
Bank.CountTabs
~~~~~~~~~~~~~~
.. pascal:: function TRSBank.CountTabs: Int32;

Counts the existing bank tabs.

Example
-------

  WriteLn Bank.CountTabs;
*)
function TRSBank.CountTabs: Int32;
var
  Elements: TRSInterfaceElementArray;
  I: Integer;
begin
  Elements := [
    Self.ELEMENT_TAB_0, Self.ELEMENT_TAB_1, Self.ELEMENT_TAB_2, Self.ELEMENT_TAB_3,
    Self.ELEMENT_TAB_4, Self.ELEMENT_TAB_5, Self.ELEMENT_TAB_6, Self.ELEMENT_TAB_7,
    Self.ELEMENT_TAB_8, Self.ELEMENT_TAB_9
  ];

  for I := 0 to High(Elements) do
    if Self.ElementFinder.HasColor(Elements[I], [$516471]) then
      Inc(Result);
end;

(*
Bank.GetCurrentTab
~~~~~~~~~~~
.. pascal:: function TRSBank.GetCurrentTab: Int32;

Get the current active bank tab.

Example
-------

  WriteLn Bank.GetCurrentTab;
*)
function TRSBank.GetCurrentTab: Int32;
var
  Elements: TRSInterfaceElementArray;
  I: Integer;
begin
  Elements := [
    Self.ELEMENT_TAB_0, Self.ELEMENT_TAB_1, Self.ELEMENT_TAB_2, Self.ELEMENT_TAB_3,
    Self.ELEMENT_TAB_4, Self.ELEMENT_TAB_5, Self.ELEMENT_TAB_6, Self.ELEMENT_TAB_7,
    Self.ELEMENT_TAB_8, Self.ELEMENT_TAB_9
  ];

  for I := 0 to High(Elements) do
    if not Self.ElementFinder.HasColor(Elements[I], [$232B2E]) then
      Exit(I);
end;

(*
Bank.OpenTab
~~~~~~~~~~~
.. pascal:: function TRSBank.OpenTab(Tab: Int32): Boolean;

Open the specified bank tab.

Example
-------

  Bank.OpenTab(0);
*)
function TRSBank.OpenTab(TabIndex: Int32): Boolean;
var
  Elements: TRSInterfaceElementArray;
begin
  if (not Self.IsOpen()) then
    Exit(False);
  if (Self.GetCurrentTab() = TabIndex) then
    Exit(True);

  Elements := [
    Self.ELEMENT_TAB_0, Self.ELEMENT_TAB_1, Self.ELEMENT_TAB_2, Self.ELEMENT_TAB_3,
    Self.ELEMENT_TAB_4, Self.ELEMENT_TAB_5, Self.ELEMENT_TAB_6, Self.ELEMENT_TAB_7,
    Self.ELEMENT_TAB_8, Self.ELEMENT_TAB_9
  ];
  Self.ElementFinder.Click(Elements[TabIndex]);

  Result := WaitUntil(Self.GetCurrentTab() = TabIndex, 100, SRL.TruncatedGauss(1000, 2000));
end;

(*
Bank.WithdrawItem
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.WithdrawItem(Item: TRSBankWithdrawItem; UseQuantityButtons: Boolean): Boolean;

Finds and withdraws an item.

Parameters
----------

Item
	TRSBankWithdrawItem variable to withdraw.

UseQuantityButtons  
  Determines if to use the 1,5,10,X,ALL `Quantity` buttons.

Example
-------

  var
    ItemToWithdraw: TRSBankWithdrawItem;
    
  ItemToWithdraw.Item := 'Iron full helm'; 
  ItemToWithdraw.Quantity := 5;
  ItemToWithdraw.Noted := False;  
  
  Bank.WithdrawItem(ItemToWithdraw, True);  
  
  // OR you can shorthand by passing an open array.
  
  Bank.WithdrawItem(['Iron full helm', 5, False], True);  
*)
function TRSBank.WithdrawItem(Item: TRSBankWithdrawItem; UseQuantityButtons: Boolean): Boolean; 
var
  B: TBox;
begin
  if Self.FindItem(Item.Item, B) then
    Result := Self.WithdrawHelper(B, Item.Quantity, Item.Noted, UseQuantityButtons); 
end;

function TRSBank.WithdrawSlot(Item: TRSBankWithdrawSlot; UseQuantityButtons: Boolean): Boolean;
begin
  Result := Self.WithdrawHelper(Self.GetSlotBoxes()[Item.Slot], Item.Quantity, Item.Noted, UseQuantityButtons);
end;

function TRSBank.DepositItem(Item: TRSBankDepositItem; UseQuantityButtons: Boolean): Boolean;
var
  SlotIndex: Int32;
begin
  SlotIndex := Inventory.FindItem(Item.Item);
  if (SlotIndex > -1) then
    Result := Self.DepositHelper(Inventory.GetSlotBox(SlotIndex), Item.Quantity, UseQuantityButtons);
end;

function TRSBank.DepositSlot(Item: TRSBankDepositSlot; UseQuantityButtons: Boolean): Boolean; 
begin
  Result := Self.DepositHelper(Inventory.GetSlotBox(Item.Slot), Item.Quantity, UseQuantityButtons);
end;

(*
Bank.DepositAll
~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.DepositAll: Boolean;

Deposits the entire inventory by clicking the deposit inventory button
*)
function TRSBank.DepositAll: Boolean;
begin
  Result := (Inventory.Count() = 0) or Self.ElementFinder.Toggle(Self.ELEMENT_DEPOSIT_INVENTORY, RSColors.BUTTON_RED, 5);
end;

procedure TRSBank.Setup(Name: String); override;
begin
  inherited;

  Self.ItemFinder.Name := Name + '.ItemFinder';
  Self.ItemFinder.GetSearchBoxesFunction := @Self.FindItemBoundaries;

  with Self.BoundsFinder.Alignments[ERSClientMode.FIXED] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 2];
    Bottom := [@InterfaceArea.Y2, -1];

    Center.MaxWidth := 488;
    Center.MaxHeight := 800;
  end;

  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 2];
    Bottom := [@InterfaceArea.Y2, -2];

    Center.MaxWidth := 488;
    Center.MaxHeight := 800;
  end;

  // Same as above
  Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_MODERN] := Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC];
end;

(*
var Bank
~~~~~~~~
  Global Bank variable.
*)
var
  Bank: TRSBank;

begin
  Bank.Setup('Bank');
end;

(*
GameTabs.Open
~~~~~~~~~~~~~
.. pascal:: function TRSGameTabs.Open(Tab: ERSGameTab): Boolean; override;

Overrides **GameTabs.Open** to close the bank if the bank open.
*)
function TRSGameTabs.Open(Tab: ERSGameTab): Boolean; override;
begin
  if Bank.IsOpen() then
  begin
    if (Tab = ERSGameTab.INVENTORY) then
      Exit(True);

    Bank.Close();
  end;

  Result := inherited();
end;
