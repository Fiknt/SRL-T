{$DEFINE SRL_MAKE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

const
  MAKE_QUANTITY_ALL = -1;

type
  TRSMake = record(TRSInterface)
  class const
    ELEMENT_BUTTON_AREA:   TRSInterfaceElement = [9, 49, 503, 76];
    ELEMENT_QUANTITY_AREA: TRSInterfaceElement = [268, 13, 244, 34];
  var
    ItemCache: array of record
      Item: String;
      Index: Int32;
    end;
  end;

function TRSMake.IsOpen: Boolean; overload;
var
  FoundBounds: TBox;
begin
  Result := OCR.LocateText(Self.Bounds, 'like to make', RS_FONT_BOLD_12, TOCRColorFilter.Create([RSColors.TEXT_BROWN]), FoundBounds) = 1;
end;

function TRSMake.IsOpen(WaitTime: Int32; Interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 1500);

  Result := WaitUntil(Self.IsOpen(), Interval, WaitTime);
end;

function TRSMake.SetQuantity(Amount: Int32): Boolean;

  function FixText(Str: String): String;
  begin
    Result := Str.Replace('I', 'l'); // Glyphs are the same.
  end;

var
  Text: String;
  I: Integer;
  B: TBox;
  Buttons: TBoxArray;
begin
  Text := ToString(Amount);
  if (Amount = MAKE_QUANTITY_ALL) then
    Text := 'All';

  for B in Self.FindQuantityButtons() do
  begin
    // Already selected
    if FixText(OCR.Recognize(B, TOCRColorFilter.Create([RSColors.TEXT_WHITE]), RS_FONT_PLAIN_11)) = Text then
      Exit(True);

    // Select
    if FixText(OCR.Recognize(B, TOCRColorFilter.Create([RSColors.TEXT_BROWN]), RS_FONT_PLAIN_11)) = Text then
    begin
      Mouse.Click(B, MOUSE_LEFT);

      Exit(True);
    end;
  end;

  for B in Self.FindQuantityButtons() do
    if OCR.Recognize(B, TOCRColorFilter.Create([RSColors.TEXT_BROWN]), RS_FONT_PLAIN_11) = 'X' then
    begin
      Mouse.Click(B, MOUSE_LEFT);

      Result := Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2500, 3500));
      Exit;
    end;
end;

function TRSMake.FindItemButtons: TBoxArray;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
begin
  if SRL.FindColors(TPA, CTS2(6982560, 10, 0.02, 0.61), Self.ElementFinder.Bounds(Self.ELEMENT_BUTTON_AREA)) then
  begin
    ATPA := TPA.Cluster(3);
    ATPA.FilterDimensions(25, 50);

    Result := ATPA.ToTBA();
  end;
end;

function TRSMake.FindQuantityButtons: TBoxArray;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
begin
  if SRL.FindColors(TPA, CTS2(6982560, 10, 0.02, 0.61), Self.ElementFinder.Bounds(Self.ELEMENT_QUANTITY_AREA)) then
  begin
    ATPA := TPA.Cluster(3);
    ATPA.FilterDimensions(15, 15);

    Result := ATPA.ToTBA();
  end;
end;

function TRSMake.SelectHelper(Boxes: TBoxArray; Index, Quantity: Integer; UseKeyboard: Boolean = True): Boolean;

  function GetKey(B: TBox): Integer;
  begin
    if (Length(Boxes) = 1) then
      Exit(VK_SPACE);

    B.Y1 := B.Y2;
    B.Y2 := B.Y2 + 15;

    case OCR.Recognize(B, TOCRColorFilter.Create([RSColors.TEXT_BROWN]), RS_FONT_PLAIN_11) of
      'Space': Result := VK_SPACE;
      '0':     Result := VK_0;
      '1':     Result := VK_1;
      '2':     Result := VK_2;
      '3':     Result := VK_3;
      '4':     Result := VK_4;
      '5':     Result := VK_5;
      '6':     Result := VK_6;
      '7':     Result := VK_7;
      '8':     Result := VK_8;
      '9':     Result := VK_9;
      else
        Result := VK_UNKNOWN;
    end;
  end;

var
  Key: Integer;
begin
  if Result := InRange(Index, Low(Boxes), High(Boxes)) then
  begin
    Self.SetQuantity(Quantity);

    if UseKeyboard then
    begin
      Key := GetKey(Boxes[Index]);
      if (Key <> VK_UNKNOWN) then
      begin
        Keyboard.PressKey(Key);
        Exit;
      end;
    end;

    Mouse.Click(Boxes[Index], MOUSE_LEFT);
  end;
end;

function TRSMake.Select(Index: Int32; Quantity: Int32; UseKeyboard: Boolean = True): Boolean; overload;
begin
  Result := Self.SelectHelper(Self.FindItemButtons(), Index, Quantity, UseKeyboard);
end;

function TRSMake.Select(Item: String; Quantity: Int32; UseKeyboard: Boolean = True): Boolean; overload;

  function ReadHint: String;
  var
    TPA: TPointArray;
  begin
    if WaitUntil(FindColors(TPA, RSColors.HINT_BACKGROUND, Self.Bounds()), SRL.TruncatedGauss(100, 1000), 5000) then
      Result := OCR.Recognize(TPA.Bounds(), TOCRColorFilter.Create([RSColors.TEXT_BLACK]), RS_FONT_PLAIN_12);
  end;

var
  Boxes: TBoxArray;
  I: Int32;
begin
  Boxes := Self.FindItemButtons();
  for I := High(Self.ItemCache) downto 0 do
    if (Self.ItemCache[I].Item = Item) then
    begin
      if Self.SelectHelper(Boxes, Self.ItemCache[I].Index, Quantity, UseKeyboard) then
        Exit(True);

      Self.ItemCache.Delete(I, 1);
    end;

  Self.SetQuantity(Quantity);

  for I := 0 to High(Boxes) do
  begin
    Mouse.Move(Boxes[I]);
    if Item.ToLower() in ReadHint().ToLower() then
    begin
      Self.ItemCache.SetLength(Self.ItemCache.Length() + 1);
      Self.ItemCache[Self.ItemCache.High()].Index := I;
      Self.ItemCache[Self.ItemCache.High()].Item := Item;

      Result := Self.SelectHelper(Boxes, I, Quantity, UseKeyboard);
      Exit;
    end;

    Wait(0, 1000, wdLeft);
  end;
end;

procedure TRSMake.Setup(Name: String); override;
begin
  inherited;

  // Same bounds as chatbox
  Self.BoundsFinder.Alignments := Chat.BoundsFinder.Alignments;
end;

var
  Make: TRSMake;

begin
  Make.Setup('Make');
end;

