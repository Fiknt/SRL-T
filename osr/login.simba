(*
Login
=====

Handles logging in players.

Summary: 

- Add players with `Login.AddPlayer`
- Login the current player with `Login.LoginPlayer`
- Switch to the next player with `Login.NextPlayer`

Example
-------

  Login.AddPlayer('myusername', 'mypassword');
  if not Login.LoginPlayer() then
    TerminateScript('Failed to login!');
*)

{$DEFINE SRL_LOGIN_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSLoginPlayer = record
    User: String;
    Password: String;
    Pin: String; 
    Worlds: TIntegerArray;
    Active: Boolean;
    BioHash: Double;
  end;

  TRSLogin = record(TRSInterface)
  class const
    ELEMENT_EXISTING_USER:  TRSInterfaceElement = [395, 275, 135, 33];
    ELEMENT_WS_OPEN:        TRSInterfaceElement = [8, 465, 94, 31];
    ELEMENT_LOGIN:          TRSInterfaceElement = [235, 305, 135, 33];
    ELEMENT_LOGIN_FIELD:    TRSInterfaceElement = [312, 240, 239, 18];
    ELEMENT_PASSWORD_FIELD: TRSInterfaceElement = [342, 257, 209, 12];
    ELEMENT_WS_CANCEL:      TRSInterfaceElement = [708, 4, 50, 16];
    ELEMENT_LOGIN_RESPONSE: TRSInterfaceElement = [211, 183, 340, 56];
    ELEMENT_ENTER_GAME:     TRSInterfaceElement = [272, 296, 221, 82];
  var
    Players: array of TRSLoginPlayer;
    PlayerIndex: Int32;
    
    AllowDangerousWorlds: Boolean;
  end;

const
  LOGIN_MESSAGE_NONE = '';
  LOGIN_MESSAGE_CONNECTING = 'Connecting to server';
  LOGIN_MESSAGE_INVALID_CREDENTIALS = 'Invalid credentials';
  LOGIN_MESSAGE_NEED_SKILL_TOTAL = 'You need a skill total of';
  LOGIN_MESSAGE_INVALID_USER_PASS = 'Please enter your username/email address.';
  LOGIN_MESSAGE_ERROR_CONNECTING = 'Error connecting to server';
  LOGIN_MESSAGE_ACCOUNT_NOT_LOGGED_OUT = 'Your account has not logged out';
  LOGIN_MESSAGE_LOGIN_SERVER_OFFLINE = 'Login server offline';
  LOGIN_MESSAGE_ERROR_LOADING_PROFILE = 'Error loading your profile';
  LOGIN_MESSAGE_CONNECTION_TIMED_OUT = 'Connection timed out';
  LOGIN_MESSAGE_LOGIN_LIMIT_EXCEEDED = 'Login limit exceeded';
  LOGIN_MESSAGE_WORLD_FULL = 'This world is full';
  LOGIN_MESSAGE_ACCOUNT_DISABLED = 'Your account has been disabled';
  LOGIN_MESSAGE_MEMBERS = 'You need a members account';
  LOGIN_MESSAGE_IN_MEMBERS_AREA = 'You are standing in a members-only area';
  LOGIN_MESSAGE_AUTHENTICATOR = 'Authenticator';

  LOGIN_MESSAGES = [
    LOGIN_MESSAGE_CONNECTING,
    LOGIN_MESSAGE_INVALID_CREDENTIALS,
    LOGIN_MESSAGE_NEED_SKILL_TOTAL,
    LOGIN_MESSAGE_INVALID_USER_PASS,
    LOGIN_MESSAGE_ERROR_CONNECTING,
    LOGIN_MESSAGE_ACCOUNT_NOT_LOGGED_OUT,
    LOGIN_MESSAGE_LOGIN_SERVER_OFFLINE,
    LOGIN_MESSAGE_ERROR_LOADING_PROFILE,
    LOGIN_MESSAGE_CONNECTION_TIMED_OUT,
    LOGIN_MESSAGE_LOGIN_LIMIT_EXCEEDED,
    LOGIN_MESSAGE_WORLD_FULL,
    LOGIN_MESSAGE_ACCOUNT_DISABLED,
    LOGIN_MESSAGE_MEMBERS,
    LOGIN_MESSAGE_IN_MEMBERS_AREA
  ];

  LOGIN_DIALOG_OK = 'Ok';
  LOGIN_DIALOG_TRY_AGAIN = 'Try again';
  LOGIN_DIALOG_CONTINUE = 'Continue';

  LOGIN_DIALOGS: TStringArray = [
    LOGIN_DIALOG_OK,
    LOGIN_DIALOG_TRY_AGAIN
  ];

  LOGIN_DIALOGS_DANGEROUS: TStringArray = [
    LOGIN_DIALOG_CONTINUE
  ];

function TRSLogin.ClickWorld(World: Int32): Boolean;
var
  B: TBox;
begin
  Result := OCR.LocateText(Self.Bounds, ToString(World), RS_FONT_BOLD_12, TOCRColorFilter.Create([$000000]), B) = 1;
  
  if Result then 
  begin
    if (not Self.AllowDangerousWorlds) then
    begin
      // normal free(silver) or members(gold) world
      if (SRL.CountColor(CTS1(4089471, 20), B) = 0) and
         (SRL.CountColor(CTS1(8421504, 25), B) = 0) then
        Self.Fatal('Not allowed to login to dangerous worlds (' + ToString(World) + ')');
    end;
    
    Mouse.Click(B, MOUSE_LEFT);
  end;
end;

function TRSLogin.IsOpen: Boolean;
begin
  Result := Self.ElementFinder.HasText(Self.ELEMENT_WS_OPEN, [RSColors.TEXT_WHITE], 'Click to switch', RS_FONT_PLAIN_11) or
            Self.IsWorldSwitcherOpen();
end;

function TRSLogin.IsWorldSwitcherOpen: Boolean;
begin
  Result := Self.ElementFinder.HasText(Self.ELEMENT_WS_CANCEL, [RSColors.TEXT_WHITE], 'Cancel', RS_FONT_PLAIN_11);
end;

function TRSLogin.OpenWorldSwitcher: Boolean;
begin
  Self.ElementFinder.Click(Self.ELEMENT_WS_OPEN);

  Result := WaitUntil(Self.IsWorldSwitcherOpen(), 500, 8000);
end;

function TRSLogin.CloseWorldSwitcher: Boolean;
begin
  if (not Self.IsOpen()) or (not Self.IsWorldSwitcherOpen()) then
    Exit(True);

  Keyboard.PressKey(VK_ESCAPE);

  Result := WaitUntil(not Self.IsWorldSwitcherOpen(), 500, 2000);
end;

function TRSLogin.GetCurrentWorld: Int32;
begin
  Result := Self.ElementFinder.ReadNumber(Self.ELEMENT_WS_OPEN, [RSColors.TEXT_WHITE], RS_FONT_BOLD_12);
end;

function TRSLogin.SwitchToWorld(World: Int32): Boolean;
begin
  if Self.GetCurrentWorld() = World then
    Exit(True);

  if Self.OpenWorldSwitcher() then
  begin
    for 1 to 3 do // Three pages of worlds
    begin
      if Self.ClickWorld(World) then
      begin
        Result := Self.GetCurrentWorld() = World;
        Exit;
      end;
      
      Keyboard.PressKey(VK_RIGHT);
      
      Wait(500, 5000, wdLeft);
    end;
  end;
end;

function TRSLogin.HandleDialogs: Boolean;
var
  Dialog: String;
begin
  if Self.ElementFinder.HasText(Self.ELEMENT_EXISTING_USER, [RSColors.TEXT_WHITE], 'Existing User', RS_FONT_BOLD_12) then
  begin
    Self.ElementFinder.Click(Self.ELEMENT_EXISTING_USER);

    Exit(True);
  end;

  for Dialog in LOGIN_DIALOGS + LOGIN_DIALOGS_DANGEROUS do
    if Self.ElementFinder.HasText(Self.ELEMENT_LOGIN, [RSColors.TEXT_WHITE], Dialog, RS_FONT_BOLD_12) then
    begin
      if (Dialog in LOGIN_DIALOGS_DANGEROUS) and (not Self.AllowDangerousWorlds) Then
        Self.Fatal('Not allowed to login to dangerous worlds (' + ToString(Self.GetCurrentWorld()) + ')');

      Self.ElementFinder.Click(Self.ELEMENT_LOGIN);

      Exit(True);
    end;
end;

function TRSLogin.EnterField(Element: TRSInterfaceElement; Text: String): Boolean;
begin
  Result := True;
  if Self.ElementFinder.HasText(Element, [RSColors.TEXT_WHITE], Text + ' ', RS_FONT_BOLD_12) then
    Exit;

  // Move caret
  while not WaitUntil(Self.ElementFinder.CountColor(Element, [RSColors.TEXT_YELLOW]) > 10, 100, SRL.TruncatedGauss(800, 1600)) do
  begin
    if not Self.IsOpen() then
      Exit(False);

    Keyboard.PressKey(VK_TAB);
  end;

  // Erase field
  while Self.ElementFinder.HasColor(Element, [RSColors.TEXT_WHITE]) do
  begin
    if not Self.IsOpen() then
      Exit(False);

    Keyboard.PressKey(VK_BACK);
  end;
  Keyboard.Send(Text);

  Wait(0, 1000, wdLeft);
end;

function TRSLogin.GetLoginMessage: String;
var
  Message: String;
begin
  Result := LOGIN_MESSAGE_NONE;

  for Message in LOGIN_MESSAGES do
    if Self.ElementFinder.HasText(Self.ELEMENT_LOGIN_RESPONSE, [RSColors.TEXT_YELLOW], Message, RS_FONT_BOLD_12) then
      Exit(Message);
end;

function TRSLogin.HandleMessage(Message: String): Boolean;
begin
  Self.DebugLn('Handling login message: ' + Message);

  case Message of
    // Cannot recover
    LOGIN_MESSAGE_MEMBERS,
    LOGIN_MESSAGE_IN_MEMBERS_AREA,
    LOGIN_MESSAGE_NEED_SKILL_TOTAL,
    LOGIN_MESSAGE_ACCOUNT_DISABLED,
    LOGIN_MESSAGE_AUTHENTICATOR:
      Result := False;

    // Retry
    LOGIN_MESSAGE_INVALID_CREDENTIALS,
    LOGIN_MESSAGE_INVALID_USER_PASS:
      Result := True;

    // Retry after ~15 seconds
    LOGIN_MESSAGE_ERROR_CONNECTING,
    LOGIN_MESSAGE_ACCOUNT_NOT_LOGGED_OUT,
    LOGIN_MESSAGE_LOGIN_SERVER_OFFLINE,
    LOGIN_MESSAGE_ERROR_LOADING_PROFILE,
    LOGIN_MESSAGE_CONNECTION_TIMED_OUT,
    LOGIN_MESSAGE_LOGIN_LIMIT_EXCEEDED,
    LOGIN_MESSAGE_WORLD_FULL:
      begin
        Wait(10000, 20000);

        Result := True;
      end;

    // No handler
    else
      Self.Fatal('Unknown login message');
  end;
end;

function TRSLogin.ClickEnterGame: Boolean;
begin
  Result := Self.ElementFinder.HasText(Self.ELEMENT_ENTER_GAME, [RSColors.TEXT_WHITE], 'CLICK HERE TO PLAY', RS_FONT_BOLD_12);
  if Result then
    Self.ElementFinder.Click(Self.ELEMENT_ENTER_GAME);
end;

function TRSLogin.EnterGame: Boolean;
begin
  Result := WaitUntil(Self.ClickEnterGame() or RSClient.IsLoggedIn(), 100, 3500) and RSClient.IsLoggedIn(3500);
end;

function TRSLogin.GetPlayer: TRSLoginPlayer;
begin
  if Self.Players = [] then
    Self.Fatal('No players declared');
  if not InRange(Self.PlayerIndex, Low(Self.Players), High(Self.Players)) then
    Self.Fatal('Player is out of range');

  Result := Self.Players[Self.PlayerIndex];
end;

function TRSLogin.LoginPlayer: Boolean;
var
  Message: String;
  Attempts, World: Int32;
  Player: TRSLoginPlayer;
begin
  Self.DebugLn('Logging in player');

  Player := Self.GetPlayer();
  if (Player.User = '') or (Player.Password = '') then
    Self.Fatal('Player has no username or password');

  while Self.IsOpen() and (Attempts < 10) do
  begin
    Self.DebugLn('Attempt ' + ToString(Attempts + 1));

   {
    if (Player.Worlds <> []) and (not (Self.GetCurrentWorld() in Player.Worlds)) then
    begin
      World := Player.Worlds[Random(Length(Player.Worlds))];
      if (not Self.SwitchToWorld(World)) then
        Exit;
    end;
    }
    
    if not Self.HandleDialogs() then
    begin
      if Self.EnterField(Self.ELEMENT_LOGIN_FIELD, Player.User) and
         Self.EnterField(Self.ELEMENT_PASSWORD_FIELD, Player.Password) then
      begin
        Keyboard.PressKey(VK_ENTER);

        while Self.IsOpen() and (Self.GetLoginMessage() in [LOGIN_MESSAGE_CONNECTING, LOGIN_MESSAGE_NONE]) do
          Wait(500);

        if Self.IsOpen() then
        begin
          Message := Self.GetLoginMessage();
          if not Self.HandleMessage(Message) then
            Exit(False);
        end;
      end;
    end;

    Wait(500, 1000, wdLeft);

    Inc(Attempts);
  end;

  Result := Self.EnterGame();
end;

procedure TRSLogin.AddPlayer(User, Pass: String; Pin: String = ''; Worlds: TIntegerArray = []);
begin
  Self.Players += [User, Pass, Pin, Worlds, True];
end;

procedure TRSLogin.NextPlayer(DisableCurrentPlayer: Boolean);
  
  function Next: Int32;
  var
    I: Int32;
  begin
    Result := -1;
    
    for I := Self.PlayerIndex + 1 to High(Self.Players) do
      if Self.Players[I].Active then
        Exit(I);
    for I := 0 to Self.PlayerIndex - 1 do // wrap around
      if Self.Players[I].Active then
        Exit(I);    
  end;
  
begin
  Self.Players[Self.PlayerIndex].Active := not DisableCurrentPlayer;
  
  Self.PlayerIndex := Next();
  if (Self.PlayerIndex = -1) then
    Self.Fatal('No other active players to switch to');
end;

function TRSLogin.GetPlayerPin: String;
begin
  Result := Self.GetPlayer.Pin;
  if (Length(Result) <> 4) or (not Result.IsInteger()) then
    Self.Fatal('Invalid bank pin');
end;


function TRSLogin.GetPlayerBioHash(): Double;
var
  h, i: UInt32;
  k: String;
begin
  if Self.Players = [] then
    Self.Fatal('No players declared');
  if not InRange(Self.PlayerIndex, Low(Self.Players), High(Self.Players)) then
    Self.Fatal('Player is out of range');

  if Self.Players[Self.PlayerIndex].BioHash = 1 then
    Self.Players[Self.PlayerIndex].BioHash := 0.9999999999999999
  else if Self.Players[Self.PlayerIndex].BioHash = 0 then
  begin
    k := Self.Players[Self.PlayerIndex].User;
    h := $811C9DC5;
    for i:=1 to Length(k) do
      h := (h * $1000193) xor Ord(k[i]);

    Self.Players[Self.PlayerIndex].BioHash := h / $FFFFFFFF;
  end;

  Result := Self.Players[Self.PlayerIndex].BioHash;
end;


procedure TRSLogin.Draw(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen() then
    Exit;

  inherited;
end;

procedure TRSLogin.Setup(Name: String); override;
begin
  inherited;

  with Self.BoundsFinder.Alignments[ERSClientMode.FIXED] do
  begin
    Left := [@RootInterface.X1];
    Right := [@RootInterface.X2];
    Top := [@RootInterface.Y1];
    Bottom := [@RootInterface.Y1, 502];
    Center := [764, 0];
  end;

  // Same as above
  Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC] := Self.BoundsFinder.Alignments[ERSClientMode.FIXED];
  Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_MODERN]  := Self.BoundsFinder.Alignments[ERSClientMode.FIXED];
end;

var
  Login: TRSLogin;

begin
  Login.Setup('Login');
end;
