{$DEFINE SRL_INTERFACE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

{$I interface_boundsfinder.simba}
{$I interface_itemfinder.simba}
{$I interface_element.simba}

type
  TRSInterface = record(TSRLBaseRecord)
    Mode: ERSClientMode;

    BoundsFinder: TRSInterfaceBoundsFinder;
    ElementFinder: TRSInterfaceElementFinder;
    ItemFinder: TRSInterfaceItemFinder;

    ButtonColors: array of TCTS1Color;
    ButtonEnabledColors: array of TCTS1Color;
  end;

var
  RSInterfaces: array of ^TRSInterface;
  
procedure TRSInterface.Setup(Name: String);
begin
  RSInterfaces += @Self;

  Self.Name := Name;
  Self.BoundsFinder.Name := Name + '.BoundsFinder';
  Self.ElementFinder.Name := Name + '.ElementFinder';
  Self.ElementFinder.GetBoundsFunction := @Self.BoundsFinder.Find;
  Self.ItemFinder.Name := Name + '.ItemFinder';
end;

function TRSInterface.Bounds: TBox;
begin
  Result := Self.BoundsFinder.Find(RSClient.ClientMode);
end;

function TRSInterface.X1: Int32;
begin
  Result := Self.Bounds.X1;
end;

function TRSInterface.X2: Int32;
begin
  Result := Self.Bounds.X2;
end;

function TRSInterface.Y1: Int32;
begin
  Result := Self.Bounds.Y1;
end;

function TRSInterface.Y2: Int32;
begin
  Result := Self.Bounds.Y2;
end;

function TRSInterface.Width: Int32;
begin
  Result := Self.Bounds.Width;
end;

function TRSInterface.Height: Int32;
begin
  Result := Self.Bounds.Height;
end;

function TRSInterface.Center: TPoint;
begin
  Result := Self.Bounds.Center;
end;

type
  TRSScrollBar = record
    SliderRegion: TBox;
    Slider: TBox;
    Position: Int32;
  end;

procedure TRSScrollBar.Draw(Bitmap: TMufasaBitmap);
begin
  Bitmap.DrawBox(Self.SliderRegion, $00FFFF);
  Bitmap.DrawBox(Self.Slider, $00FFFF);
  Bitmap.SetFontAntialiasing(False);
  Bitmap.SetFontSize(20);
  with Bitmap.TextSize(ToString(Self.Position)) do
    Bitmap.DrawText(ToString(Self.Position), [Self.SliderRegion.Center.X - (X div 2), Self.Slider.Center.Y - (Y div 3)], $00FF00);
end;

function TRSScrollBar.IsVisible: Boolean;
begin
  Result := Self <> [];
end;

function TRSInterface.GetScrollBar: TRSScrollBar;
const
  COLOR_ARROW := CTS2(5206147, 15, 0.03, 0.28);
  COLOR_BORDER := 65536;
var
  TPA: TPointArray;
  Arrows: TBoxArray;
  Area, B: TBox;
begin
  Area := Self.Bounds();

  if SRL.FindColors(TPA, COLOR_ARROW, Area) > 0 then
  begin
    for B in TPA.Cluster(1).BoundsArray() do
      if (B.Width = 14) and (B.Height = 14) and (SRL.CountColor(COLOR_BORDER, B.Expand(1, Area)) = 62) then
        Arrows += B;

    Arrows := Arrows.SortByX(False);

    if (Length(Arrows) >= 2) and (Arrows[0].X1 = Arrows[1].X1) and (Arrows[1].X2 = Arrows[1].X2) then
    begin
      if (Arrows[0].Y1 > Arrows[1].Y1) then
        Swap(Arrows[0], Arrows[1]);

      B.X1 := Arrows[0].X1;
      B.Y1 := Arrows[0].Y2 + 2;
      B.X2 := Arrows[1].X2;
      B.Y2 := Arrows[1].Y1 - 2;

      if SRL.FindColors(TPA, COLOR_BORDER, B) > 0 then
      begin
        Result.SliderRegion := B;
        Result.Slider := TPA.Bounds;
        Result.Position := Round((Result.Slider.Y1 - Result.SliderRegion.Y1) * 100 / (Result.SliderRegion.Height - Result.Slider.Height));
      end;
    end;
  end;
end;

function TRSInterface.CanScroll: Boolean;
var
  ScrollBar: TRSScrollBar := Self.GetScrollBar();
begin
  Result := Scrollbar.IsVisible() and (ScrollBar.Slider <> ScrollBar.SliderRegion);
end;

function TRSInterface.GetScrollPosition: Int32;
var
  ScrollBar: TRSScrollBar;
begin
  Result := -1;

  ScrollBar := Self.GetScrollBar();
  if ScrollBar.IsVisible() then
    Result := ScrollBar.Position;
end;

procedure TRSInterface.SetScrollPosition(Value: Int32);
var
  ScrollBar: TRSScrollBar;
begin
  Value := EnsureRange(Value, 0, 100);

  ScrollBar := Self.GetScrollBar();

  if ScrollBar.IsVisible() then
  begin
    if (ScrollBar.Position < Value) then
    begin
      while ScrollBar.IsVisible() and (ScrollBar.Position < Value) do
      begin
        Mouse.Scroll(ScrollBar.SliderRegion, Random(1, 3), True);

        ScrollBar := Self.GetScrollBar();
      end;
    end else
    if (ScrollBar.Position > Value) then
    begin
      while ScrollBar.IsVisible() and (ScrollBar.Position > Value) do
      begin
        Mouse.Scroll(ScrollBar.SliderRegion, Random(1, 3), False);

        ScrollBar := Self.GetScrollBar();
      end;
    end;
  end;
end;

procedure TRSInterface.Draw(Bitmap: TMufasaBitmap);
var
  ScrollBar: TRSScrollBar;
begin
  Bitmap.DrawBox(Self.Bounds(), $00FFFF);

  ScrollBar := Self.GetScrollBar();
  if ScrollBar.IsVisible() then
    ScrollBar.Draw(Bitmap);
end;

function TRSInterface.ClickCloseButton(PressEscape: Boolean): Boolean;
var
  B: TBox;
  X, Y: Integer;
begin
  // Top right corner
  B := Self.Bounds;
  B.X1 := B.X2 - 50;
  B.Y2 := B.Y1 + 50;

  Result := FindBitmapTolerance(RSBitmaps.CloseInterfaceButton, X, Y, B, 45);
  if Result then
    case PressEscape of
      True:  Keyboard.PressKey(VK_ESCAPE);
      False: Mouse.Click(Box(X, Y, X + RSBitmaps.CloseInterfaceButton.GetWidth(), Y + RSBitmaps.CloseInterfaceButton.GetHeight()), MOUSE_LEFT);
    end;
end;

function TRSInterface.IsTitle(Text: String; MinMatch: Single = 0.80): Boolean;
var
  B: TBox;
begin
  B := Self.Bounds();
  B.X1 += 70;
  B.Y1 += 10;
  B.X2 -= 70;
  B.Y2 := B.Y1 + 18;
  B.Clip(Self.Bounds);

  Result := OCR.LocateText(B, Text, RS_FONT_BOLD_12, TOCRInvertColorFilter.Create([3358536, 0], [5, 0]), B) > MinMatch;
end;

type
  TRSRootInterface = type TRSInterface;

function TRSRootInterface.CustomBoundsFinder(ClientMode: ERSClientMode): TBox;
var
  W, H: Integer;
begin
  GetClientDimensions(W, H);

  Result.X1 := 0;
  Result.Y1 := 0;
  Result.X2 := W-1;
  Result.Y2 := H-1;
end;

procedure TRSRootInterface.Setup(Name: String); override;
begin
  inherited;

  Self.BoundsFinder.CustomFunction := @Self.CustomBoundsFinder;
end;

var
  RootInterface: TRSRootInterface;

begin
  RootInterface.Setup('Root Interface');
end;
